MODULE main

	VAR
		status: {disponivel, reservado, atrasado};
		multa_pendente: boolean;
		requisitado: boolean;
		entregue: boolean;
		com_atraso: boolean;
		system : process livro(status, multa_pendente, requisitado, entregue, com_atraso);

	ASSIGN
		init(status) := disponivel;
		--init(multa_pendente) := FALSE;
		--init(requisitado) := FALSE;
		--init(com_atraso):= FALSE;
		--init(entregue):= FALSE;

MODULE livro(status, multa_pendente, requisitado, entregue, com_atraso)

	ASSIGN
		next(multa_pendente) :=
			case
				-- entrega com atraso
				(status = reservado) & (entregue = TRUE) & (com_atraso= TRUE): TRUE;

				-- entrega sem atraso
				(status = reservado) & (entregue = TRUE) & (com_atraso= FALSE): FALSE;

				FALSE: multa_pendente;
			esac;

		next(status) := 
			case
				-- casos base
				(status = disponivel) & (requisitado = TRUE): {reservado};
				(status = atrasado) & (requisitado = TRUE): {atrasado};
				(status = reservado) & (requisitado = TRUE): {reservado};
				(status = reservado) & (entregue = FALSE): {reservado};

				-- casos para entrega
				(status = reservado) & (entregue = TRUE) & (com_atraso= TRUE): {atrasado};
				(status = reservado) & (entregue = TRUE) & (com_atraso= FALSE): {disponivel};

				-- casos para atrasado
				(status = atrasado) & (multa_pendente = FALSE): {disponivel};
				(status = atrasado) & (multa_pendente = TRUE): {atrasado};

				TRUE: status; -- nao muda nada
			esac;

		
	FAIRNESS
		running
		


SPEC AF(status = disponivel & requisitado = TRUE -> status = reservado)
SPEC AF(status = disponivel & requisitado = FALSE -> status = disponivel)

SPEC EF(status = reservado & entregue = TRUE & com_atraso = TRUE -> status = atrasado & multa_pendente = TRUE)
SPEC EF(status = reservado & entregue = TRUE & com_atraso = FALSE -> status = disponivel)

SPEC AF(status = atrasado & multa_pendente = TRUE -> status = atrasado)
SPEC AF(status = atrasado & multa_pendente = FALSE -> status = disponivel)

-- Talvez seja bom usar DEFINE para juntar os estados e definir em uma coisa so